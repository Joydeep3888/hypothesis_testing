

import re

def parse_proc_content(proc_content, program_name_patterns, special_programs):
    program_blocks = []
    current_program = None
    current_dsn_disp = None

    for line in proc_content.splitlines():
        # Skip comments and non-program lines
        if line.startswith('//*') or line.startswith('//**') or not line.startswith('//'):
            continue

        # Check for program names
        for pattern in program_name_patterns:
            match = pattern.match(line)
            if match:
                # Start a new block for the new program
                program_name = match.group(1)
                if program_name not in special_programs:
                    if current_program:
                        # Save the previous program block if it exists
                        program_blocks.append({
                            'program_name': current_program,
                            'dsn_disp': current_dsn_disp
                        })
                    # Reset the DSN/DISP pair for the new program
                    current_program = program_name
                    current_dsn_disp = []
                break  # Exit the loop after finding a program name

        # After finding a program, look for DSN and DISP values
        if current_program:
            dsn_match = re.search(r'DSN=([^,]*)', line, re.IGNORECASE)
            disp_match = re.search(r'DISP=([^,]*)', line, re.IGNORECASE)
            if dsn_match and disp_match:
                dsn_disp_pair = (dsn_match.group(1).strip(), disp_match.group(1).strip())
                # Add the DSN/DISP pair if it's not already in the list for the current program
                if dsn_disp_pair not in current_dsn_disp:
                    current_dsn_disp.append(dsn_disp_pair)

    # Don't forget to save the last program block
    if current_program:
        program_blocks.append({
            'program_name': current_program,
            'dsn_disp': current_dsn_disp
        })

    return program_blocks
