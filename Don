

import re

def parse_proc_content(proc_content, program_name_patterns, special_programs):
    program_blocks = []
    current_program = None
    current_dsn_disp = None

    for line in proc_content.splitlines():
        # Skip comments and non-program lines
        if line.startswith('//*') or line.startswith('//**') or not line.startswith('//'):
            continue

        # Check for program names
        for pattern in program_name_patterns:
            match = pattern.match(line)
            if match:
                # Start a new block for the new program
                program_name = match.group(1)
                if program_name not in special_programs:
                    if current_program:
                        # Save the previous program block if it exists
                        program_blocks.append({
                            'program_name': current_program,
                            'dsn_disp': current_dsn_disp
                        })
                    # Reset the DSN/DISP pair for the new program
                    current_program = program_name
                    current_dsn_disp = []
                break  # Exit the loop after finding a program name

        # After finding a program, look for DSN and DISP values
        if current_program:
            dsn_match = re.search(r'DSN=([^,]*)', line, re.IGNORECASE)
            disp_match = re.search(r'DISP=([^,]*)', line, re.IGNORECASE)
            if dsn_match and disp_match:
                dsn_disp_pair = (dsn_match.group(1).strip(), disp_match.group(1).strip())
                # Add the DSN/DISP pair if it's not already in the list for the current program
                if dsn_disp_pair not in current_dsn_disp:
                    current_dsn_disp.append(dsn_disp_pair)

    # Don't forget to save the last program block
    if current_program:
        program_blocks.append({
            'program_name': current_program,
            'dsn_disp': current_dsn_disp
        })

    return program_blocks


import os
import re
import pandas as pd

# Define your patterns and other functions here ...

# Assume parse_proc_content is defined as shown in the previous example
# ...

def traverse_and_extract(job_file_path, proc_file_path):
    jobs_procs_programs = []

    # Traverse the CG_Jobs directory
    for root, dirs, files in os.walk(job_file_path):
        for file in files:
            job_names = extract_job_and_proc_name(file)
            if job_names:
                job_name = job_names[0]
                with open(os.path.join(root, file), 'r') as file_content:
                    content_lines = [line for line in file_content if pattern.match(line)]
                    content = "".join(content_lines)
                    proc_names = extract_proc_names(content)
                    prg_names_in_job = extract_program_names(content)

                    # For each proc_name, find the corresponding file in the CG_Procs directory
                    for proc_name in proc_names:
                        proc_matched = False
                        for proc_root, proc_dirs, proc_files in os.walk(proc_file_path):
                            for proc_file in proc_files:
                                if proc_name in extract_job_and_proc_name(proc_file):
                                    proc_matched = True
                                    with open(os.path.join(proc_root, proc_file), 'r') as proc_file_content:
                                        proc_content_lines = [line for line in proc_file_content if pattern.match(line)]
                                        proc_content = "".join(proc_content_lines)
                                        
                                        # Parse the proc content for program names and associated DSN/DISP
                                        program_blocks = parse_proc_content(proc_content, program_name_patterns, special_programs)
                                        
                                        # Iterate over the program blocks to collect the job-proc-program relationship
                                        for block in program_blocks:
                                            for dsn_disp in block['dsn_disp']:
                                                jobs_procs_programs.append({
                                                    'job_name': job_name,
                                                    'proc_name': proc_name,
                                                    'prg_name_in_proc': block['program_name'],
                                                    'prg_name_in_job': 'na',  # No direct program name in job
                                                    'dsn_filename': dsn_disp[0],
                                                    'disp_value': dsn_disp[1]
                                                })

                        # Handle the case where the proc is not found
                        if not proc_matched:
                            jobs_procs_programs.append({
                                'job_name': job_name,
                                'proc_name': proc_name,
                                'prg_name_in_proc': 'na',  # No proc file, hence no program name
                                'prg_name_in_job': 'na',  # No direct program name in job
                                'dsn_filename': 'na',  # No DSN since no proc file
                                'disp_value': 'na'  # No DISP since no proc file
                            })

                    # Process the program names directly in the job files
                    # ...

    # Convert the collected data into a DataFrame
    df = pd.DataFrame(jobs_procs_programs)
    # ... (Rest of your DataFrame processing)

    return df

# Example usage
job_file_path = "/path/to/job/files"
proc_file_path = "/path/to/proc/files"
df = traverse_and_extract(job_file_path, proc_file_path)
