


# Testing the updated parse_proc_content function with the sample PROC content

# Redefining the extract_dsn_filename and extract_disposition functions for testing
def extract_dsn_filename(line):
    dsn_pattern = re.compile(r'DD\s+DSN=([^,]+)', re.IGNORECASE)
    matches = dsn_pattern.findall(line)
    return [match.strip() for match in matches]

def extract_disposition(line):
    disp_pattern = re.compile(r'DISP=([a-zA-Z0-9_]+)', re.IGNORECASE)
    matches = disp_pattern.findall(line)
    return [match.strip() for match in matches]

# Updated parse_proc_content function based on the previous response
def parse_proc_content(proc_content):
    program_patterns = [
        re.compile(r'^\/\/\S+\s+EXEC\s+PGM=([a-zA-Z0-9_]+)', re.IGNORECASE),
        re.compile(r'^\/\/.*?PARM=\'[^,]+,\s*([a-zA-Z0-9_]+)', re.IGNORECASE),
        re.compile(r'^\/\/.*?PARM=BMP,\s*([a-zA-Z0-9_]+)', re.IGNORECASE),
        re.compile(r'^\/\/.*?RUN\s+PROGRAM=([a-zA-Z0-9_]+)', re.IGNORECASE),
    ]
    special_program_pattern = re.compile(r'^\/\/\S+\s+EXEC\s+PGM=(DFSRRC00|IKJEFT01)', re.IGNORECASE)
    special_param_pattern = re.compile(r"^\/\/.*PARM\=\(\'([^\']+)\'\)", re.IGNORECASE)

    results = []
    current_program = None
    handle_special_program = False
    dsn_matches, disp_matches = [], []

    for line in proc_content.splitlines():
        if line.startswith('//*') or line.startswith('//**'):
            continue  # Ignore comment lines

        special_program_match = special_program_pattern.match(line)
        if special_program_match:
            handle_special_program = True  # Indicate special program handling
            continue

        if handle_special_program:
            special_param_match = special_param_pattern.match(line)
            if special_param_match:
                current_program = special_param_match.group(1)  # Use special program name
                handle_special_program = False  # Reset flag
                continue  # Skip to next iteration

        for pattern in program_patterns:
            program_match = pattern.match(line)
            if program_match:
                # Found a regular program name, save any pending DSN/DISP pairs for the previous program
                if current_program:
                    for dsn, disp in zip(dsn_matches, disp_matches):
                        results.append({
                            'program_name_inside_proc': current_program,
                            'dsn_file_name': dsn,
                            'disp_value': disp
                        })
                # Update current program
                current_program = program_match.group(1)
                dsn_matches, disp_matches = extract_dsn_filename(line), extract_disposition(line)
                break  # Found a match, no need to check other patterns

        if not special_program_match and not program_match:
            # Line doesn't define a new program, check for DSN/DISP for the current program
            dsn_matches += extract_dsn_filename(line)
            disp_matches += extract_disposition(line)

    # After all lines are processed, save any remaining DSN/DISP pairs for the last program
    if current_program:
        for dsn, disp in zip(dsn_matches, disp_matches):
            results.append({
                'program_name_inside_proc': current_program,
                'dsn_file_name': dsn,
                'disp_value': disp
            })

    return results

# Sample PROC content for testing
proc_content_test = """
//STEP1 EXEC PGM=PROGRAM1
//DD1 DD DSN=filename1,DISP=SHR
//STEP2 EXEC PGM=DFSRRC00
//PARM=('SPECIAL1')
//DD2 DD DSN=filename2,DISP=NEW
//STEP3 EXEC PGM=PROGRAM2
//DD3 DD DSN=filename3,DISP=OLD
//STEP4 EXEC RUN PROGRAM=PROGRAM3
//DD4 DD DSN=filename4,DISP=MOD
"""

# Run the test
test_results = parse_proc_content(proc_content_test)

# Display the updated test results
test_results
